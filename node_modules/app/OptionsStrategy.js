var BlackScholes = require('app/BlackScholes');
var is_numeric = requires('app/is_numeric');
var is_array = requires('app/is_array');
var is_int = requires('app/is_int');
var array_sum = requires('app/array_sum');

var OptionsStrategy = function(portfolio) {
// array of BlackScholes objects
  if(!is_array(portfolio)) throw("Portfolio should be an array");
  if(portfolio.length==0) throw("Portfolio is empty");
  portfolio.forEach(function(p) {
    if(!p.hasOwnProperty("o")) throw("Portfolio missing o key");
    if(!p.hasOwnProperty("q")) throw("Portfolio missing q key");
    if(!is_int(p["q"])) throw("quantity should be numeric integer");
    if(! p["o"] instanceof BlackScholes ) throw("Portfolio should be array of BlackScholes objects");
  });

  // test no duplicates
  ids=portfolio.map(function(p) { return p["o"].id(); });
  if(ids.length!=array_unique(ids).length) throw("Duplicate options in portfolio detected");

  // portfolio being keyed by portfolio ID and stored in class member
  this.portfolio={};
  for(portfolio as pk) {
    var p = portfolio[pk];
    this.portfolio[p["o"].id()]=p;
  }
}

var OptionsStrategy.loss = function(S,t,mult=1) {
// S: underlying value
// t: physical time
// mult: factor with which to multiply the loss... useful for this.margin

  if(!mult.is_numeric()) throw("mult should be numeric");
  return this.loss2(this.loss1(S,t),mult,S,t);
}

var OptionsStrategy.loss1 = function(S,t) {
// sub-function of loss
  vals={};
  for(this.portfolio as id) {
    var p = this.portfolio[id];
    var v=p["o"].value(S,t);
    if(is_array(v)) {
      var q=p["q"];
      // 1st dimension: S
      v=v.map(function(vi) {
        if(is_array(vi)) {
          // 2nd dimension: t
          return vi.map(function(vii) { return vii*q; });
        } else {
          return vi*q;
        }
      }); 
    } else {
      v=v*p["q"];
    }

    // swap dimensions of options with (S,t)
    if(is_array(v)) {
      for(v as ki) {
        var vi = v[ki];
        if(!vals.hasOwnProperty(ki)) vals[ki]={};
        if(is_array(vi)) {
          for(vi as kii) {
            var vii = vi[kii];
            if(!vals[ki].hasOwnProperty(kii)) vals[ki][kii]={};
            vals[ki][kii][id]=vii;
          }
        } else {
          vals[ki][id]=vi;
        }
      }
    } else {
      vals[id]=v;
    }
  }

  return vals;
}

var OptionsStrategy.loss2 = function(vals,mult,S,t) {
// sub-function of loss
  if(!is_array(S)&&!is_array(t)) {
    vals = array_sum(vals);
    vals = Math.min(vals,0)*mult;
  } else {
    if(is_array(S)&&is_array(t)) {
      for(vals as ki) {
        var vi = vals[ki];
        for(vi as kii) {
          var vii = vi[kii];
          vii = array_sum(vii);
          vii = Math.min(vii,0)*mult;
          vals[ki][kii] = vii;
        }
      }
    } else {
      if(!is_array(S)||!is_array(t)) {
        for(vals as ki) {
          var vi = vals[ki];
          vi = array_sum(vi);
          vi = Math.min(vi,0)*mult;
          vals[ki] = vi;
        }
      } else {
        throw("WTF");
      }
    }
  }
  return vals;
}

var OptionsStrategy.margin = function(S,t) {
  m=this.loss(S,t,-1);

  if(!is_array(S)&&!is_array(t)) {
    if(this.portfolio.length==1) return m; // this would be numeric in this case
    return m;
  } else {
    if(is_array(S)&&is_array(t)) {
      return Math.max(Math.max(m));
    } else {
      if(!is_array(S)||!is_array(t)) {
        return Math.max(m);
      } else {
        throw("WTF");
      }
    }
  }
}

} // end class
