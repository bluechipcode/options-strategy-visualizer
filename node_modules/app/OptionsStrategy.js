var BlackScholes = require('app/BlackScholes');
var is_numeric = require('app/is_numeric');
var is_array = require('app/is_array');
var is_int = require('app/is_int');
var array_sum = require('app/array_sum');
var array_unique = require('app/array_unique');
var array_values = require('app/array_values');
var array_max = require('app/array_max');

var OptionsStrategy = function(portfolio) {
// array of BlackScholes objects
  if(!is_array(portfolio)) throw("Portfolio should be an array");
  if(portfolio.length==0) throw("Portfolio is empty");
  portfolio.forEach(function(p) {
    if(!p.hasOwnProperty("o")) throw("Portfolio missing o key");
    if(!p.hasOwnProperty("q")) throw("Portfolio missing q key");
    if(!is_int(p["q"])) throw("quantity should be numeric integer");
    if(! p["o"] instanceof BlackScholes ) throw("Portfolio should be array of BlackScholes objects");
  });

  // test no duplicates
  ids=portfolio.map(function(p) { return p["o"].id(); });
  if(ids.length!=array_unique(ids).length) throw("Duplicate options in portfolio detected");

  // portfolio being keyed by portfolio ID and stored in class member
  this.portfolio={};
  for(var i=0;i<Object.keys(portfolio).length;i++) {
    var p = portfolio[i];
    this.portfolio[p["o"].id()]=p;
  }
}

OptionsStrategy.prototype.loss = function(S,t,mult) {
// S: underlying value
// t: physical time
// mult: factor with which to multiply the loss... useful for this.margin

  mult = typeof mult === 'undefined'?1:mult;
  if(!is_numeric(mult)) throw("mult should be numeric");
  return this.loss2(this.loss1(S,t),mult,S,t);
}

OptionsStrategy.prototype.loss1 = function(S,t) {
// sub-function of loss
  vals={};
  for(var id in this.portfolio) {
    var p = this.portfolio[id];
    var v=p["o"].value(S,t);
    if(!is_numeric(v)) {
      // 1st dimension: S
      for(var ki in v) {
        if(!is_numeric(v[ki])) {
          // 2nd dimension: t
          for(var kii in v[ki]) {
            v[ki][kii] =  v[ki][kii]*p.q;
          }
        } else {
          v[ki] = v[ki]*p.q;
        }
      } 
    } else {
      v=v*p.q;
    }

    // swap dimensions of options with (S,t)
    if(!is_numeric(v)) {
      for(var ki in v) {
        if(!vals.hasOwnProperty(ki)) vals[ki]={};
        if(!is_numeric(v[ki])) {
          for(var kii in v[ki]) {
            if(!vals[ki].hasOwnProperty(kii)) vals[ki][kii]={};
            vals[ki][kii][id]=v[ki][kii];
          }
        } else {
          vals[ki][id]=v[ki];
        }
      }
    } else {
      vals[id]=v;
    }
  }
  return vals;
}

OptionsStrategy.prototype.loss2 = function(vals,mult,S,t) {
// sub-function of loss
  if(is_numeric(S)&&is_numeric(t)) {
    vals = array_sum(array_values(vals));
    vals = Math.min(vals,0)*mult;
  } else {
    if(!is_numeric(S)&&!is_numeric(t)) {
      for(var ki in vals) {
        var vi = vals[ki];
        for(var kii in vi) {
          var vii = vi[kii];
          vii = array_sum(array_values(vii));
          vii = Math.min(vii,0)*mult;
          vals[ki][kii] = vii;
        }
      }
    } else {
      if(is_numeric(S)||is_numeric(t)) {
        for(var ki in vals) {
          var vi = vals[ki];
          vi = array_sum(array_values(vi));
          vi = Math.min(vi,0)*mult;
          vals[ki] = vi;
        }
      } else {
        throw("WTF");
      }
    }
  }
  return vals;
}

OptionsStrategy.prototype.margin = function(S,t) {
  m=this.loss(S,t,-1);
  if(is_numeric(S)&&is_numeric(t)) {
    if(this.portfolio.length==1) return m; // this would be numeric in this case
    return m;
  } else {
    if(!is_numeric(S)&&!is_numeric(t)) {
      var m2 = array_values(m).map(function(x) { return array_values(x); });
      var m3 = m2.map(array_max);
      var m4 = array_max(m3);
      return m4;
    } else {
      if(is_numeric(S)||is_numeric(t)) {
        return array_max(array_values(m));
      } else {
        throw("WTF");
      }
    }
  }
}

module.exports = function(portfolio) {
  return new OptionsStrategy(portfolio);
};
